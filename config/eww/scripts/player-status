#! /usr/bin/env python3

# Script that controls some eww variables related to the music/video status in 
# the top bar and the notification panel. This script tries it best to overcome 
# the weird behaviours of the players and the limitations of the playerctl utili- ty and even after these attempts, its still a quite a bit hacky.
import os
import json
import threading
import subprocess
from subprocess import Popen
from enum import Enum

class PlayerStatus(Enum):
    Inactive = 0
    Playing  = 1
    Paused   = 2

class PlayerState:
    def __init__(self, player, status=PlayerStatus.Inactive, title=None, artist=None):
        self.player = player
        self.status = status
        self.title  = title
        self.artist = artist

    def is_playing(self):
        return self.status == PlayerStatus.Playing

    def is_paused(self):
        return self.status == PlayerStatus.Paused

    def is_active(self):
        return self.status != PlayerStatus.Inactive

    def get_thumbnail(self):
        thumbnail_uri = playerctl_get_metadata_field(self.player, "mpris:artUrl")
        thumbnail_path = None

        # The mpris:artUrl field means different things depending on the player
        match self.player:
            case "firefox":
                # Thumbnail URI is a file (file://foo/bar)
                thumbnail_path = thumbnail_uri.removeprefix("file://")
            case "spotify":
                # Thumbnail URI is a HTTP URI (http://foo/bar)
                thumbnail_path = "/tmp/" + thumbnail_uri.split("/")[-1]
                # Downloads thumbnail from URI into tmp folder if not done before
                if not os.path.exists(thumbnail_path):
                    subprocess.run(["curl", thumbnail_uri, "-o", thumbnail_path, ">", "/dev/null"])

        return thumbnail_path

    def export(self):
        return {
            "player": self.player,
            "title": self.title,
            "artist": self.artist,
            "thumbnail": self.get_thumbnail(),
            "playing": self.is_playing(),
            "active": self.is_active(),
        }


# Global variables
players = ["spotify", "chromium", "firefox"]
player_states = { players[i]:PlayerState(players[i]) for i in range(len(players)) } 


def playerctl_send_command(player, command):
    return subprocess.run(
        ["playerctl", "-p", player] + command.split(" "),
        stdout=subprocess.PIPE, text=True
    ).stdout.strip()


def playerctl_get_status(player):
    match playerctl_send_command(player, "status"):
        case "Playing":
            return PlayerStatus.Playing
        case "Paused":
            return PlayerStatus.Paused
        case _:
            return PlayerStatus.Inactive


def playerctl_get_metadata_field(player, field):
    return playerctl_send_command(player, f"metadata {field}")


# Updates values in the PlayerState of the corresponding player
def update_player_state(player):
    state = player_states[player]

    state.status = playerctl_get_status(player)
    
    if state.status != PlayerStatus.Inactive:
        state.title  = playerctl_get_metadata_field(player, "title")
        state.artist = playerctl_get_metadata_field(player, "artist")
    else:
        state.title  = None
        state.artist = None


# Thread task for each player. Reads continuously the output of playerctl
# with "-F metadata" args and controls the state of the PlayerState objects
def track_player_state(player_name, ready):
    print(f"Thread {player_name} started")

    # Creates command for especific player
    format_str = "{{playerName}} {{status}} {{title}} {{artist}}"
    cmd = ["playerctl", "-p", player_name, "-F", "metadata", "-f", format_str, ">", "/dev/null"]

    with Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True) as p:
        for _ in p.stdout:
            update_player_state(player_name)
            with ready:
                ready.notify()
                
        print(f"Thread {player_name} stopped")


# Updates the player_state variable in Eww using a JSON format
def update_eww(state):
    subprocess.run([
        "eww",
        "update",
        f"player_state={json.dumps(state.export())}"
    ])


# Script entry point
if __name__ == "__main__":
    ready = threading.Condition()
    player_threads = []

    # Starts thread for each player
    for player in players:
        t = threading.Thread(target=track_player_state, args=[player, ready])
        t.start()
        player_threads.append(t)

    # Waits for the player threads to update its respectives PlayerState objects
    # and updates the variables used by eww
    fallback_state = PlayerState("none", status=PlayerStatus.Inactive)
    while True:
        with ready:
            ready.wait()

            # Initializes state with fallback variable
            state_to_use = fallback_state

            # Iterates over list of PlayerStates, which are already ordered from
            # highest to lowest priority and selects the first one that is active
            for state in list(player_states.values()):
                if state.is_active():
                    state_to_use = state
                    break;
            update_eww(state_to_use)

    # TODO: handle SIGTERM signal to kill threads and reset the player
    # state: update_eww(fallback_state)
    for thread in player_threads:
        thread.join()

